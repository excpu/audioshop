{"version":3,"file":"465.bundle.js","mappings":"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","sources":["webpack://audioshop/./node_modules/music-metadata/lib/flac/FlacParser.js","webpack://audioshop/./node_modules/music-metadata/lib/id3v2/AbstractID3Parser.js","webpack://audioshop/./node_modules/music-metadata/lib/ogg/vorbis/Vorbis.js","webpack://audioshop/./node_modules/music-metadata/lib/ogg/vorbis/VorbisDecoder.js","webpack://audioshop/./node_modules/music-metadata/lib/ogg/vorbis/VorbisParser.js"],"sourcesContent":["import { UINT16_BE, UINT24_BE, Uint8ArrayType } from 'token-types';\nimport initDebug from 'debug';\nimport * as util from '../common/Util.js';\nimport { VorbisPictureToken } from '../ogg/vorbis/Vorbis.js';\nimport { AbstractID3Parser } from '../id3v2/AbstractID3Parser.js';\nimport { FourCcToken } from '../common/FourCC.js';\nimport { VorbisParser } from '../ogg/vorbis/VorbisParser.js';\nimport { VorbisDecoder } from '../ogg/vorbis/VorbisDecoder.js';\nimport { makeUnexpectedFileContentError } from '../ParseError.js';\nconst debug = initDebug('music-metadata:parser:FLAC');\nclass FlacContentError extends makeUnexpectedFileContentError('FLAC') {\n}\n/**\n * FLAC supports up to 128 kinds of metadata blocks; currently the following are defined:\n * ref: https://xiph.org/flac/format.html#metadata_block\n */\nvar BlockType;\n(function (BlockType) {\n    BlockType[BlockType[\"STREAMINFO\"] = 0] = \"STREAMINFO\";\n    BlockType[BlockType[\"PADDING\"] = 1] = \"PADDING\";\n    BlockType[BlockType[\"APPLICATION\"] = 2] = \"APPLICATION\";\n    BlockType[BlockType[\"SEEKTABLE\"] = 3] = \"SEEKTABLE\";\n    BlockType[BlockType[\"VORBIS_COMMENT\"] = 4] = \"VORBIS_COMMENT\";\n    BlockType[BlockType[\"CUESHEET\"] = 5] = \"CUESHEET\";\n    BlockType[BlockType[\"PICTURE\"] = 6] = \"PICTURE\";\n})(BlockType || (BlockType = {}));\nexport class FlacParser extends AbstractID3Parser {\n    constructor() {\n        super(...arguments);\n        this.vorbisParser = new VorbisParser(this.metadata, this.options);\n        this.padding = 0;\n    }\n    async postId3v2Parse() {\n        const fourCC = await this.tokenizer.readToken(FourCcToken);\n        if (fourCC.toString() !== 'fLaC') {\n            throw new FlacContentError('Invalid FLAC preamble');\n        }\n        let blockHeader;\n        do {\n            // Read block header\n            blockHeader = await this.tokenizer.readToken(BlockHeader);\n            // Parse block data\n            await this.parseDataBlock(blockHeader);\n        } while (!blockHeader.lastBlock);\n        if (this.tokenizer.fileInfo.size && this.metadata.format.duration) {\n            const dataSize = this.tokenizer.fileInfo.size - this.tokenizer.position;\n            this.metadata.setFormat('bitrate', 8 * dataSize / this.metadata.format.duration);\n        }\n    }\n    async parseDataBlock(blockHeader) {\n        debug(`blockHeader type=${blockHeader.type}, length=${blockHeader.length}`);\n        switch (blockHeader.type) {\n            case BlockType.STREAMINFO:\n                return this.parseBlockStreamInfo(blockHeader.length);\n            case BlockType.PADDING:\n                this.padding += blockHeader.length;\n                break;\n            case BlockType.APPLICATION:\n                break;\n            case BlockType.SEEKTABLE:\n                break;\n            case BlockType.VORBIS_COMMENT:\n                return this.parseComment(blockHeader.length);\n            case BlockType.CUESHEET:\n                break;\n            case BlockType.PICTURE:\n                await this.parsePicture(blockHeader.length);\n                return;\n            default:\n                this.metadata.addWarning(`Unknown block type: ${blockHeader.type}`);\n        }\n        // Ignore data block\n        return this.tokenizer.ignore(blockHeader.length).then();\n    }\n    /**\n     * Parse STREAMINFO\n     */\n    async parseBlockStreamInfo(dataLen) {\n        if (dataLen !== BlockStreamInfo.len)\n            throw new FlacContentError('Unexpected block-stream-info length');\n        const streamInfo = await this.tokenizer.readToken(BlockStreamInfo);\n        this.metadata.setFormat('container', 'FLAC');\n        this.metadata.setFormat('codec', 'FLAC');\n        this.metadata.setFormat('lossless', true);\n        this.metadata.setFormat('numberOfChannels', streamInfo.channels);\n        this.metadata.setFormat('bitsPerSample', streamInfo.bitsPerSample);\n        this.metadata.setFormat('sampleRate', streamInfo.sampleRate);\n        if (streamInfo.totalSamples > 0) {\n            this.metadata.setFormat('duration', streamInfo.totalSamples / streamInfo.sampleRate);\n        }\n    }\n    /**\n     * Parse VORBIS_COMMENT\n     * Ref: https://www.xiph.org/vorbis/doc/Vorbis_I_spec.html#x1-640004.2.3\n     */\n    async parseComment(dataLen) {\n        const data = await this.tokenizer.readToken(new Uint8ArrayType(dataLen));\n        const decoder = new VorbisDecoder(data, 0);\n        decoder.readStringUtf8(); // vendor (skip)\n        const commentListLength = decoder.readInt32();\n        const tags = new Array(commentListLength);\n        for (let i = 0; i < commentListLength; i++) {\n            tags[i] = decoder.parseUserComment();\n        }\n        await Promise.all(tags.map(tag => this.vorbisParser.addTag(tag.key, tag.value)));\n    }\n    async parsePicture(dataLen) {\n        if (this.options.skipCovers) {\n            return this.tokenizer.ignore(dataLen);\n        }\n        const picture = await this.tokenizer.readToken(new VorbisPictureToken(dataLen));\n        this.vorbisParser.addTag('METADATA_BLOCK_PICTURE', picture);\n    }\n}\nconst BlockHeader = {\n    len: 4,\n    get: (buf, off) => {\n        return {\n            lastBlock: util.getBit(buf, off, 7),\n            type: util.getBitAllignedNumber(buf, off, 1, 7),\n            length: UINT24_BE.get(buf, off + 1)\n        };\n    }\n};\n/**\n * METADATA_BLOCK_DATA\n * Ref: https://xiph.org/flac/format.html#metadata_block_streaminfo\n */\nconst BlockStreamInfo = {\n    len: 34,\n    get: (buf, off) => {\n        return {\n            // The minimum block size (in samples) used in the stream.\n            minimumBlockSize: UINT16_BE.get(buf, off),\n            // The maximum block size (in samples) used in the stream.\n            // (Minimum blocksize == maximum blocksize) implies a fixed-blocksize stream.\n            maximumBlockSize: UINT16_BE.get(buf, off + 2) / 1000,\n            // The minimum frame size (in bytes) used in the stream.\n            // May be 0 to imply the value is not known.\n            minimumFrameSize: UINT24_BE.get(buf, off + 4),\n            // The maximum frame size (in bytes) used in the stream.\n            // May be 0 to imply the value is not known.\n            maximumFrameSize: UINT24_BE.get(buf, off + 7),\n            // Sample rate in Hz. Though 20 bits are available,\n            // the maximum sample rate is limited by the structure of frame headers to 655350Hz.\n            // Also, a value of 0 is invalid.\n            sampleRate: UINT24_BE.get(buf, off + 10) >> 4,\n            // probably slower: sampleRate: common.getBitAllignedNumber(buf, off + 10, 0, 20),\n            // (number of channels)-1. FLAC supports from 1 to 8 channels\n            channels: util.getBitAllignedNumber(buf, off + 12, 4, 3) + 1,\n            // bits per sample)-1.\n            // FLAC supports from 4 to 32 bits per sample. Currently the reference encoder and decoders only support up to 24 bits per sample.\n            bitsPerSample: util.getBitAllignedNumber(buf, off + 12, 7, 5) + 1,\n            // Total samples in stream.\n            // 'Samples' means inter-channel sample, i.e. one second of 44.1Khz audio will have 44100 samples regardless of the number of channels.\n            // A value of zero here means the number of total samples is unknown.\n            totalSamples: util.getBitAllignedNumber(buf, off + 13, 4, 36),\n            // the MD5 hash of the file (see notes for usage... it's a littly tricky)\n            fileMD5: new Uint8ArrayType(16).get(buf, off + 18)\n        };\n    }\n};\n//# sourceMappingURL=FlacParser.js.map","import { EndOfStreamError } from 'strtok3';\nimport initDebug from 'debug';\nimport { ID3v2Header } from './ID3v2Token.js';\nimport { ID3v2Parser } from './ID3v2Parser.js';\nimport { ID3v1Parser } from '../id3v1/ID3v1Parser.js';\nimport { BasicParser } from '../common/BasicParser.js';\nconst debug = initDebug('music-metadata:parser:ID3');\n/**\n * Abstract parser which tries take ID3v2 and ID3v1 headers.\n */\nexport class AbstractID3Parser extends BasicParser {\n    constructor() {\n        super(...arguments);\n        this.id3parser = new ID3v2Parser();\n    }\n    static async startsWithID3v2Header(tokenizer) {\n        return (await tokenizer.peekToken(ID3v2Header)).fileIdentifier === 'ID3';\n    }\n    async parse() {\n        try {\n            await this.parseID3v2();\n        }\n        catch (err) {\n            if (err instanceof EndOfStreamError) {\n                debug(\"End-of-stream\");\n            }\n            else {\n                throw err;\n            }\n        }\n    }\n    finalize() {\n        return;\n    }\n    async parseID3v2() {\n        await this.tryReadId3v2Headers();\n        debug('End of ID3v2 header, go to MPEG-parser: pos=%s', this.tokenizer.position);\n        await this.postId3v2Parse();\n        if (this.options.skipPostHeaders && this.metadata.hasAny()) {\n            this.finalize();\n        }\n        else {\n            const id3v1parser = new ID3v1Parser(this.metadata, this.tokenizer, this.options);\n            await id3v1parser.parse();\n            this.finalize();\n        }\n    }\n    async tryReadId3v2Headers() {\n        const id3Header = await this.tokenizer.peekToken(ID3v2Header);\n        if (id3Header.fileIdentifier === 'ID3') {\n            debug('Found ID3v2 header, pos=%s', this.tokenizer.position);\n            await this.id3parser.parse(this.metadata, this.tokenizer, this.options);\n            return this.tryReadId3v2Headers();\n        }\n    }\n}\n//# sourceMappingURL=AbstractID3Parser.js.map","import * as Token from 'token-types';\nimport { AttachedPictureType } from '../../id3v2/ID3v2Token.js';\n/**\n * Parse the METADATA_BLOCK_PICTURE\n * Ref: https://wiki.xiph.org/VorbisComment#METADATA_BLOCK_PICTURE\n * Ref: https://xiph.org/flac/format.html#metadata_block_picture\n * // ToDo: move to ID3 / APIC?\n */\nexport class VorbisPictureToken {\n    static fromBase64(base64str) {\n        return VorbisPictureToken.fromBuffer(Uint8Array.from(atob(base64str), c => c.charCodeAt(0)));\n    }\n    static fromBuffer(buffer) {\n        const pic = new VorbisPictureToken(buffer.length);\n        return pic.get(buffer, 0);\n    }\n    constructor(len) {\n        this.len = len;\n    }\n    get(buffer, offset) {\n        const type = AttachedPictureType[Token.UINT32_BE.get(buffer, offset)];\n        offset += 4;\n        const mimeLen = Token.UINT32_BE.get(buffer, offset);\n        offset += 4;\n        const format = new Token.StringType(mimeLen, 'utf-8').get(buffer, offset);\n        offset += mimeLen;\n        const descLen = Token.UINT32_BE.get(buffer, offset);\n        offset += 4;\n        const description = new Token.StringType(descLen, 'utf-8').get(buffer, offset);\n        offset += descLen;\n        const width = Token.UINT32_BE.get(buffer, offset);\n        offset += 4;\n        const height = Token.UINT32_BE.get(buffer, offset);\n        offset += 4;\n        const colour_depth = Token.UINT32_BE.get(buffer, offset);\n        offset += 4;\n        const indexed_color = Token.UINT32_BE.get(buffer, offset);\n        offset += 4;\n        const picDataLen = Token.UINT32_BE.get(buffer, offset);\n        offset += 4;\n        const data = Uint8Array.from(buffer.slice(offset, offset + picDataLen));\n        return {\n            type,\n            format,\n            description,\n            width,\n            height,\n            colour_depth,\n            indexed_color,\n            data\n        };\n    }\n}\n/**\n * Comment header decoder\n * Ref: https://xiph.org/vorbis/doc/Vorbis_I_spec.html#x1-620004.2.1\n */\nexport const CommonHeader = {\n    len: 7,\n    get: (buf, off) => {\n        return {\n            packetType: Token.UINT8.get(buf, off),\n            vorbis: new Token.StringType(6, 'ascii').get(buf, off + 1)\n        };\n    }\n};\n/**\n * Identification header decoder\n * Ref: https://xiph.org/vorbis/doc/Vorbis_I_spec.html#x1-630004.2.2\n */\nexport const IdentificationHeader = {\n    len: 23,\n    get: (uint8Array, off) => {\n        return {\n            version: Token.UINT32_LE.get(uint8Array, off + 0),\n            channelMode: Token.UINT8.get(uint8Array, off + 4),\n            sampleRate: Token.UINT32_LE.get(uint8Array, off + 5),\n            bitrateMax: Token.UINT32_LE.get(uint8Array, off + 9),\n            bitrateNominal: Token.UINT32_LE.get(uint8Array, off + 13),\n            bitrateMin: Token.UINT32_LE.get(uint8Array, off + 17)\n        };\n    }\n};\n//# sourceMappingURL=Vorbis.js.map","import * as Token from 'token-types';\nexport class VorbisDecoder {\n    constructor(data, offset) {\n        this.data = data;\n        this.offset = offset;\n    }\n    readInt32() {\n        const value = Token.UINT32_LE.get(this.data, this.offset);\n        this.offset += 4;\n        return value;\n    }\n    readStringUtf8() {\n        const len = this.readInt32();\n        const value = new TextDecoder('utf-8').decode(this.data.subarray(this.offset, this.offset + len));\n        this.offset += len;\n        return value;\n    }\n    parseUserComment() {\n        const offset0 = this.offset;\n        const v = this.readStringUtf8();\n        const idx = v.indexOf('=');\n        return {\n            key: v.slice(0, idx).toUpperCase(),\n            value: v.slice(idx + 1),\n            len: this.offset - offset0\n        };\n    }\n}\n//# sourceMappingURL=VorbisDecoder.js.map","import * as Token from 'token-types';\nimport debugInit from 'debug';\nimport { VorbisDecoder } from './VorbisDecoder.js';\nimport { CommonHeader, IdentificationHeader, VorbisPictureToken } from './Vorbis.js';\nimport { makeUnexpectedFileContentError } from '../../ParseError.js';\nconst debug = debugInit('music-metadata:parser:ogg:vorbis1');\nexport class VorbisContentError extends makeUnexpectedFileContentError('Vorbis') {\n}\n/**\n * Vorbis 1 Parser.\n * Used by OggParser\n */\nexport class VorbisParser {\n    constructor(metadata, options) {\n        this.metadata = metadata;\n        this.options = options;\n        this.pageSegments = [];\n    }\n    /**\n     * Vorbis 1 parser\n     * @param header Ogg Page Header\n     * @param pageData Page data\n     */\n    async parsePage(header, pageData) {\n        if (header.headerType.firstPage) {\n            this.parseFirstPage(header, pageData);\n        }\n        else {\n            if (header.headerType.continued) {\n                if (this.pageSegments.length === 0) {\n                    throw new VorbisContentError('Cannot continue on previous page');\n                }\n                this.pageSegments.push(pageData);\n            }\n            if (header.headerType.lastPage || !header.headerType.continued) {\n                // Flush page segments\n                if (this.pageSegments.length > 0) {\n                    const fullPage = VorbisParser.mergeUint8Arrays(this.pageSegments);\n                    await this.parseFullPage(fullPage);\n                }\n                // Reset page segments\n                this.pageSegments = header.headerType.lastPage ? [] : [pageData];\n            }\n        }\n        if (header.headerType.lastPage) {\n            this.calculateDuration(header);\n        }\n    }\n    static mergeUint8Arrays(arrays) {\n        const totalSize = arrays.reduce((acc, e) => acc + e.length, 0);\n        const merged = new Uint8Array(totalSize);\n        arrays.forEach((array, i, _arrays) => {\n            const offset = _arrays.slice(0, i).reduce((acc, e) => acc + e.length, 0);\n            merged.set(array, offset);\n        });\n        return merged;\n    }\n    async flush() {\n        await this.parseFullPage(VorbisParser.mergeUint8Arrays(this.pageSegments));\n    }\n    async parseUserComment(pageData, offset) {\n        const decoder = new VorbisDecoder(pageData, offset);\n        const tag = decoder.parseUserComment();\n        await this.addTag(tag.key, tag.value);\n        return tag.len;\n    }\n    async addTag(id, value) {\n        if (id === 'METADATA_BLOCK_PICTURE' && (typeof value === 'string')) {\n            if (this.options.skipCovers) {\n                debug(\"Ignore picture\");\n                return;\n            }\n            value = VorbisPictureToken.fromBase64(value);\n            debug(`Push picture: id=${id}, format=${value.format}`);\n        }\n        else {\n            debug(`Push tag: id=${id}, value=${value}`);\n        }\n        await this.metadata.addTag('vorbis', id, value);\n    }\n    calculateDuration(header) {\n        if (this.metadata.format.sampleRate && header.absoluteGranulePosition >= 0) {\n            // Calculate duration\n            this.metadata.setFormat('numberOfSamples', header.absoluteGranulePosition);\n            this.metadata.setFormat('duration', header.absoluteGranulePosition / this.metadata.format.sampleRate);\n        }\n    }\n    /**\n     * Parse first Ogg/Vorbis page\n     * @param header\n     * @param pageData\n     */\n    parseFirstPage(header, pageData) {\n        this.metadata.setFormat('codec', 'Vorbis I');\n        debug('Parse first page');\n        // Parse  Vorbis common header\n        const commonHeader = CommonHeader.get(pageData, 0);\n        if (commonHeader.vorbis !== 'vorbis')\n            throw new VorbisContentError('Metadata does not look like Vorbis');\n        if (commonHeader.packetType === 1) {\n            const idHeader = IdentificationHeader.get(pageData, CommonHeader.len);\n            this.metadata.setFormat('sampleRate', idHeader.sampleRate);\n            this.metadata.setFormat('bitrate', idHeader.bitrateNominal);\n            this.metadata.setFormat('numberOfChannels', idHeader.channelMode);\n            debug('sample-rate=%s[hz], bitrate=%s[b/s], channel-mode=%s', idHeader.sampleRate, idHeader.bitrateNominal, idHeader.channelMode);\n        }\n        else\n            throw new VorbisContentError('First Ogg page should be type 1: the identification header');\n    }\n    async parseFullPage(pageData) {\n        // New page\n        const commonHeader = CommonHeader.get(pageData, 0);\n        debug('Parse full page: type=%s, byteLength=%s', commonHeader.packetType, pageData.byteLength);\n        switch (commonHeader.packetType) {\n            case 3: //  type 3: comment header\n                return this.parseUserCommentList(pageData, CommonHeader.len);\n            case 1: // type 1: the identification header\n            case 5: // type 5: setup header type\n                break; // ignore\n        }\n    }\n    /**\n     * Ref: https://xiph.org/vorbis/doc/Vorbis_I_spec.html#x1-840005.2\n     */\n    async parseUserCommentList(pageData, offset) {\n        const strLen = Token.UINT32_LE.get(pageData, offset);\n        offset += 4;\n        // const vendorString = new Token.StringType(strLen, 'utf-8').get(pageData, offset);\n        offset += strLen;\n        let userCommentListLength = Token.UINT32_LE.get(pageData, offset);\n        offset += 4;\n        while (userCommentListLength-- > 0) {\n            offset += (await this.parseUserComment(pageData, offset));\n        }\n    }\n}\n//# sourceMappingURL=VorbisParser.js.map"],"names":["debug","FlacContentError","BlockType","FlacParser","constructor","super","arguments","this","vorbisParser","metadata","options","padding","postId3v2Parse","tokenizer","readToken","toString","blockHeader","BlockHeader","parseDataBlock","lastBlock","fileInfo","size","format","duration","dataSize","position","setFormat","type","length","STREAMINFO","parseBlockStreamInfo","PADDING","APPLICATION","SEEKTABLE","VORBIS_COMMENT","parseComment","CUESHEET","PICTURE","parsePicture","addWarning","ignore","then","dataLen","BlockStreamInfo","len","streamInfo","channels","bitsPerSample","sampleRate","totalSamples","data","Uint8ArrayType","decoder","readStringUtf8","commentListLength","readInt32","tags","Array","i","parseUserComment","Promise","all","map","tag","addTag","key","value","skipCovers","picture","get","buf","off","UINT24_BE","minimumBlockSize","UINT16_BE","maximumBlockSize","minimumFrameSize","maximumFrameSize","fileMD5","AbstractID3Parser","id3parser","startsWithID3v2Header","peekToken","fileIdentifier","parse","parseID3v2","err","finalize","tryReadId3v2Headers","skipPostHeaders","hasAny","id3v1parser","VorbisPictureToken","fromBase64","base64str","fromBuffer","Uint8Array","from","atob","c","charCodeAt","buffer","offset","mimeLen","descLen","description","width","height","colour_depth","indexed_color","picDataLen","slice","CommonHeader","packetType","vorbis","IdentificationHeader","uint8Array","version","channelMode","bitrateMax","bitrateNominal","bitrateMin","VorbisDecoder","TextDecoder","decode","subarray","offset0","v","idx","indexOf","toUpperCase","VorbisContentError","VorbisParser","pageSegments","parsePage","header","pageData","headerType","firstPage","parseFirstPage","continued","push","lastPage","fullPage","mergeUint8Arrays","parseFullPage","calculateDuration","arrays","totalSize","reduce","acc","e","merged","forEach","array","_arrays","set","flush","id","absoluteGranulePosition","commonHeader","idHeader","byteLength","parseUserCommentList","strLen","userCommentListLength"],"sourceRoot":""}